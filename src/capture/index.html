<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Service Translate - Local Audio Processing</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .login-form {
            display: grid;
            gap: 15px;
            max-width: 400px;
            margin: 0 auto;
        }
        
        .form-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        label {
            font-weight: 500;
            font-size: 14px;
        }
        
        input, button, select {
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
        }
        
        input, select {
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }
        
        input[type="range"] {
            background: rgba(255, 255, 255, 0.3);
            height: 6px;
            padding: 0;
        }
        
        #gainValue {
            margin-left: 10px;
            font-weight: 500;
        }
        
        button {
            background: #4CAF50;
            color: white;
            cursor: pointer;
            font-weight: 500;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #45a049;
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .streaming-controls {
            text-align: center;
            margin-bottom: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 30px;
        }
        
        .translation-panel {
            flex: 1;
        }
        
        .session-input {
            text-align: center;
        }
        
        .session-input label {
            display: block;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 5px;
        }
        
        .session-input input {
            padding: 8px 12px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 14px;
            text-align: center;
            width: 200px;
        }
        
        .session-input input:focus {
            outline: none;
            border-color: #2196F3;
            background: rgba(255, 255, 255, 0.15);
        }
        
        .start-btn {
            background: #2196F3;
            font-size: 16px;
            padding: 15px 30px;
        }
        
        .stop-btn {
            background: #f44336;
        }
        
        .results-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .transcription-panel {
            min-height: 200px;
        }
        
        .translation-panel {
            min-height: 300px;
        }
        
        .translation-tabs {
            display: flex;
            margin-bottom: 15px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        .tab-button {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            padding: 10px 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            border-bottom: 2px solid transparent;
            transition: all 0.3s;
        }
        
        .tab-button.active {
            color: white;
            border-bottom-color: #FFD700;
        }
        
        .tab-button:hover {
            color: white;
            background: rgba(255, 255, 255, 0.1);
        }
        
        .tab-content {
            display: none;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 15px;
            min-height: 200px;
            max-height: 300px;
            font-size: 16px;
            line-height: 1.5;
            overflow-y: auto;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .panel-header {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .text-content {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 15px;
            min-height: 200px;
            max-height: 300px;
            font-size: 16px;
            line-height: 1.5;
            overflow-y: auto;
        }
        
        .translation-item {
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
        }
        
        .translation-lang {
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 5px;
            color: #FFD700;
        }
        
        .status {
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 500;
        }
        
        .status.success {
            background: rgba(76, 175, 80, 0.3);
        }
        
        .status.error {
            background: rgba(244, 67, 54, 0.3);
        }
        
        .status.info {
            background: rgba(33, 150, 243, 0.3);
        }
        
        .hidden {
            display: none;
        }
        
        .config-btn, .logout-btn {
            position: absolute;
            top: 20px;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 8px 15px;
            font-size: 12px;
            cursor: pointer;
        }
        
        .logout-btn {
            right: 20px;
        }
        
        .config-btn {
            right: 140px;
        }
        
        .cost-warning {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        .language-checkbox {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 14px;
        }
        
        .language-checkbox input[type="checkbox"] {
            width: auto;
            margin: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <button class="config-btn" onclick="showConfig()">‚öôÔ∏è Configuration</button>
        <button class="logout-btn hidden" onclick="adminLogout()" id="admin-logout-btn">üö™ Logout</button>
        
        <div class="header">
            <h1>üé§ ADVM Service Translate</h1>

        </div>

        <!-- Configuration Panel -->
        <div id="config-panel" class="card hidden">
            <h2>Configuration</h2>
            <div class="translation-tabs">
                <button class="tab-button active" onclick="switchConfigTab('languages')">üåç Languages</button>
                <button class="tab-button" onclick="switchConfigTab('audio')">üé§ Audio</button>
                <button class="tab-button" onclick="switchConfigTab('tts')">üîä TTS</button>
                <button class="tab-button" onclick="switchConfigTab('holyrics')">üì∫ Holyrics</button>
                <button class="tab-button" onclick="switchConfigTab('advanced')">‚öôÔ∏è Advanced</button>
            </div>
            
            <div class="tab-content active" id="config-languages">
                <div class="login-form">
                    <div class="form-group">
                        <label>Source Language:</label>
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-top: 5px;">
                            <label style="display: flex; align-items: center; gap: 5px;">
                                <input type="radio" name="sourceLanguage" value="pt-BR" checked> üáßüá∑ Portuguese
                            </label>
                            <label style="display: flex; align-items: center; gap: 5px;">
                                <input type="radio" name="sourceLanguage" value="en"> üá∫üá∏ English
                            </label>
                            <label style="display: flex; align-items: center; gap: 5px;">
                                <input type="radio" name="sourceLanguage" value="es"> üá™üá∏ Spanish
                            </label>
                            <label style="display: flex; align-items: center; gap: 5px;">
                                <input type="radio" name="sourceLanguage" value="fr"> üá´üá∑ French
                            </label>
                            <label style="display: flex; align-items: center; gap: 5px;">
                                <input type="radio" name="sourceLanguage" value="de"> üá©üá™ German
                            </label>
                            <label style="display: flex; align-items: center; gap: 5px;">
                                <input type="radio" name="sourceLanguage" value="it"> üáÆüáπ Italian
                            </label>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Target Languages:</label>
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-top: 5px;">
                            <label style="display: flex; align-items: center; gap: 5px;">
                                <input type="checkbox" id="target-pt"> üáßüá∑ Portuguese
                            </label>
                            <label style="display: flex; align-items: center; gap: 5px;">
                                <input type="checkbox" id="target-en" checked> üá∫üá∏ English
                            </label>
                            <label style="display: flex; align-items: center; gap: 5px;">
                                <input type="checkbox" id="target-es" checked> üá™üá∏ Spanish
                            </label>
                            <label style="display: flex; align-items: center; gap: 5px;">
                                <input type="checkbox" id="target-fr" checked> üá´üá∑ French
                            </label>
                            <label style="display: flex; align-items: center; gap: 5px;">
                                <input type="checkbox" id="target-de" checked> üá©üá™ German
                            </label>
                            <label style="display: flex; align-items: center; gap: 5px;">
                                <input type="checkbox" id="target-it" checked> üáÆüáπ Italian
                            </label>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="tab-content" id="config-advanced">
                <div class="login-form">
                    <div class="form-group">
                        <label>User Pool ID:</label>
                        <input type="text" id="userPoolId" placeholder="us-east-1_...">
                    </div>
                    <div class="form-group">
                        <label>Client ID:</label>
                        <input type="text" id="clientId" placeholder="...">
                    </div>
                    <div class="form-group">
                        <label>Identity Pool ID:</label>
                        <input type="text" id="identityPoolId" placeholder="us-east-1:...">
                    </div>
                    <div class="form-group">
                        <label>Region:</label>
                        <input type="text" id="region" value="us-east-1">
                    </div>
                </div>
            </div>
            
            <div class="tab-content" id="config-audio">
                <div class="login-form">
                    <div class="form-group">
                        <label>Input Device:</label>
                        <select id="inputDevice">
                            <option value="default">Default System Input</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Sample Rate:</label>
                        <select id="sampleRate">
                            <option value="16000" selected>16 kHz (Recommended)</option>
                            <option value="8000">8 kHz</option>
                            <option value="22050">22.05 kHz</option>
                            <option value="44100">44.1 kHz</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Encoding:</label>
                        <select id="encoding">
                            <option value="signed-integer" selected>16-bit PCM (Recommended)</option>
                            <option value="unsigned-integer">8-bit PCM</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Channels:</label>
                        <select id="channels">
                            <option value="1" selected>Mono (Recommended)</option>
                            <option value="2">Stereo</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Input Gain:</label>
                        <input type="range" id="inputGain" min="0" max="200" value="100" step="10">
                        <span id="gainValue">100%</span>
                    </div>
                </div>
            </div>
            
            <div class="tab-content" id="config-tts">
                <div class="login-form">
                    <div class="form-group">
                        <label>TTS Mode:</label>
                        <select id="ttsMode">
                            <option value="disabled">Disabled (Text Only)</option>
                            <option value="local">Local Device TTS</option>
                            <option value="standard">AWS Polly Standard ($4/1M chars)</option>
                            <option value="neural" selected>AWS Polly Neural ($16/1M chars)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Voice Gender:</label>
                        <select id="ttsVoiceGender">
                            <option value="female" selected>Female</option>
                            <option value="male">Male</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>TTS Server Host:</label>
                        <input type="text" id="ttsHost" placeholder="localhost" value="localhost">
                    </div>
                    <div class="form-group">
                        <label>TTS Server Port:</label>
                        <input type="number" id="ttsPort" placeholder="3001" value="3001">
                    </div>
                </div>
            </div>
            
            <div class="tab-content" id="config-holyrics">
                <div class="login-form">
                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="holyricsEnabled"> Enable Holyrics Integration
                        </label>
                    </div>
                    <div class="form-group">
                        <label>Holyrics Host:</label>
                        <input type="text" id="holyricsHost" placeholder="192.168.1.100" value="localhost">
                    </div>
                    <div class="form-group">
                        <label>Holyrics Port:</label>
                        <input type="number" id="holyricsPort" placeholder="8080" value="8080">
                    </div>
                    <div class="form-group">
                        <label>API Token:</label>
                        <input type="text" id="holyricsToken" placeholder="your-api-token">
                    </div>
                    <div class="form-group">
                        <label>Display Language:</label>
                        <select id="holyricsLanguage">
                            <option value="pt">Portuguese</option>
                            <option value="en">English</option>
                            <option value="es">Spanish</option>
                            <option value="fr">French</option>
                            <option value="de">German</option>
                            <option value="it">Italian</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Max Lines on Screen:</label>
                        <input type="number" id="holyricsMaxLines" min="1" max="10" value="3">
                    </div>
                    <div class="form-group">
                        <button onclick="testHolyricsConnection()" style="margin-top: 10px;">üß™ Test Connection</button>
                        <button onclick="clearHolyrics()" style="margin-top: 10px; margin-left: 10px;">üßπ Clear Screen</button>
                    </div>
                </div>
            </div>
            
            <button onclick="saveConfig()" style="margin-top: 20px;">Save Configuration</button>
        </div>

        <!-- Login Panel -->
        <div id="login-panel" class="card">
            <h2>üîê Admin Authentication</h2>
            <div id="login-status" class="status info hidden"></div>
            <div class="login-form">
                <div class="form-group">
                    <label>Username:</label>
                    <input type="text" id="admin-username" placeholder="admin" autocomplete="username">
                </div>
                <div class="form-group">
                    <label>Password:</label>
                    <input type="password" id="admin-password" placeholder="Enter password" autocomplete="current-password">
                </div>
                <button id="admin-login-btn">üîë Login</button>
                <div style="margin-top: 15px; text-align: center; font-size: 12px; color: rgba(255,255,255,0.7);">
                    Authenticating will create a persistent admin session
                </div>
            </div>
        </div>

        <!-- Token Expiry Warning -->
        <div id="token-expiry-warning" class="status error hidden" style="position: fixed; top: 80px; right: 20px; max-width: 350px; z-index: 1000;">
            <div style="display: flex; align-items: center; justify-content: space-between;">
                <div>
                    <strong>‚ö†Ô∏è Session Expiring Soon</strong>
                    <div id="token-expiry-message" style="font-size: 12px; margin-top: 5px;"></div>
                </div>
                <button onclick="refreshAdminToken()" style="padding: 5px 10px; font-size: 11px; margin-left: 10px;">Refresh</button>
            </div>
        </div>

        <!-- Main Application -->
        <div id="main-app" class="hidden">

            <!-- Cost Tracking Panel - Single Line -->
            <div class="card" id="cost-panel" style="margin-bottom: 20px;">
                <div style="display: flex; align-items: center; gap: 15px;">
                    <div style="flex: 1; display: flex; align-items: center; justify-content: space-between;">
                        <div style="font-weight: 600; font-size: 16px;">üí∞ Cost Tracking</div>
                        
                        <div style="display: flex; gap: 20px; align-items: center;">
                            <div style="text-align: center;">
                                <span style="font-size: 11px; color: rgba(255,255,255,0.7);">Transcribe:</span>
                                <span id="transcribe-cost" style="font-weight: bold; font-size: 13px; margin-left: 5px;">$0.00</span>
                            </div>
                            <div style="text-align: center;">
                                <span style="font-size: 11px; color: rgba(255,255,255,0.7);">Translate:</span>
                                <span id="translate-cost" style="font-weight: bold; font-size: 13px; margin-left: 5px;">$0.00</span>
                            </div>
                            <div style="text-align: center;">
                                <span style="font-size: 11px; color: rgba(255,255,255,0.7);">Polly:</span>
                                <span id="polly-cost" style="font-weight: bold; font-size: 13px; margin-left: 5px;">$0.00</span>
                            </div>
                            <div style="border-left: 2px solid rgba(255,255,255,0.3); padding-left: 20px;">
                                <span style="font-size: 11px; color: rgba(255,255,255,0.8);">Total:</span>
                                <span id="total-cost" style="font-weight: bold; font-size: 16px; color: #FFD700; margin-left: 5px;">$0.00</span>
                                <span id="hourly-rate" style="font-size: 10px; color: rgba(255,255,255,0.6); margin-left: 5px;">($0.00/hr)</span>
                            </div>
                        </div>
                    </div>
                    
                    <div id="cost-warning" class="status error hidden" style="margin: 0; padding: 5px 10px; font-size: 10px; white-space: nowrap;">
                        > $3/hr!
                    </div>
                </div>
                
                <!-- Hidden usage details for tracking -->
                <div style="display: none;">
                    <span id="transcribe-usage">0 min</span>
                    <span id="translate-usage">0 chars</span>
                    <span id="polly-usage">0 chars</span>
                </div>
            </div>

            <!-- Session Management and TTS Server Health Panels Side by Side -->
            <div style="display: flex; gap: 20px; margin-bottom: 20px;">
                <!-- Session Management Panel (2/3) -->
                <div class="card" id="session-panel" style="flex: 2;">
                    <div class="panel-header">üì° Session Management</div>
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <div>
                        <div style="font-size: 14px; color: rgba(255,255,255,0.8);">Current Session:</div>
                        <div id="current-session-id" style="font-size: 18px; font-weight: bold; color: #FFD700;">Not Connected</div>
                    </div>
                    <div style="text-align: right;">
                        <button id="refresh-sessions-btn" onclick="refreshSessions()" style="padding: 8px 15px; font-size: 12px;" disabled>üîÑ Refresh</button>
                    </div>
                </div>
                
                <!-- Session View Tabs -->
                <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                    <button id="my-sessions-tab" class="tab-button active" onclick="switchSessionView('my')" style="flex: 1; padding: 8px; font-size: 13px; border-radius: 4px;">
                        üë§ My Sessions
                    </button>
                    <button id="all-sessions-tab" class="tab-button" onclick="switchSessionView('all')" style="flex: 1; padding: 8px; font-size: 13px; border-radius: 4px;">
                        üåê All Sessions
                    </button>
                </div>
                
                <!-- Active Sessions List -->
                <div style="margin-bottom: 15px;">
                    <div style="font-size: 12px; color: rgba(255,255,255,0.7); margin-bottom: 8px;">
                        <span id="sessions-list-title">My Active Sessions:</span>
                        <span id="sessions-count" style="margin-left: 5px; color: #FFD700;">(0)</span>
                    </div>
                    <div id="sessions-list" style="max-height: 200px; overflow-y: auto; background: rgba(0,0,0,0.2); border-radius: 4px; padding: 8px;">
                        <div style="text-align: center; color: rgba(255,255,255,0.5); padding: 20px;">
                            Connect to server to view sessions
                        </div>
                    </div>
                </div>
                
                <div style="display: flex; gap: 10px; align-items: center;">
                    <label for="sessionId" style="font-size: 14px; white-space: nowrap;">Session ID:</label>
                    <input type="text" id="sessionId" placeholder="Enter session ID" value="CHURCH-2025-001" style="flex: 1; padding: 8px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); border-radius: 4px; color: white;">
                    <button onclick="createSession()" id="create-session-btn" style="padding: 8px 20px; white-space: nowrap;" disabled>üöÄ Create Session</button>
                    <button onclick="endCurrentSession()" id="end-session-btn" style="padding: 8px 20px; background: #f44336; white-space: nowrap;" class="hidden">üõë End Session</button>
                </div>
                </div>
                
                <!-- TTS Server Health Panel (1/3) -->
                <div class="card" id="websocket-panel" style="flex: 1;">
                    <div class="panel-header">üîä TTS Server</div>
                    <div style="text-align: center; margin-bottom: 10px;">
                        <div style="font-size: 11px; color: rgba(255,255,255,0.7);">Status</div>
                        <div id="ws-server-status" style="font-weight: bold; color: #999; font-size: 14px;">Unknown</div>
                        <div id="ws-server-url" style="font-size: 10px; color: rgba(255,255,255,0.5); margin-top: 2px;"></div>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; padding-bottom: 10px; border-bottom: 1px solid rgba(255,255,255,0.2);">
                        <div style="text-align: center;">
                            <div style="font-size: 11px; color: rgba(255,255,255,0.7);">Clients</div>
                            <div id="ws-client-count" style="font-weight: bold; font-size: 14px;">0</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 11px; color: rgba(255,255,255,0.7);">Sessions</div>
                            <div id="ws-session-count" style="font-weight: bold; font-size: 14px;">0</div>
                        </div>
                    </div>
                    <div style="text-align: center; margin-top: 5px; margin-bottom: 10px;">
                        <div id="ws-last-activity" style="font-size: 9px; color: rgba(255,255,255,0.5);">No activity</div>
                    </div>
                    <div>
                        <button onclick="reconnectWebSocket()" style="width: 100%; font-size: 11px; padding: 6px; margin-bottom: 5px;">üîÑ Reconnect</button>
                        <button onclick="stopWebSocketServer()" style="width: 100%; font-size: 11px; padding: 6px; background: #f44336;">üõë Stop</button>
                    </div>
                </div>
            </div>

            <div id="status" class="status">Ready</div>
            
            <div class="streaming-controls">
                <div style="display: flex; align-items: center; justify-content: center; gap: 20px;">
                    <div>
                        <button class="start-btn" onclick="startStreaming()" id="start-btn" disabled title="Create a session first">
                            üé§ Start Streaming
                        </button>
                        <button class="stop-btn hidden" onclick="stopStreaming()" id="stop-btn" style="display: none;">
                            ‚èπÔ∏è Stop Streaming
                        </button>
                    </div>
                </div>
            </div>

            <div class="results-container">
                <div class="card translation-panel">
                    <div class="panel-header">üåç All Languages</div>
                    <div class="translation-tabs">
                        <button class="tab-button active" onclick="switchTab('pt-BR')">üáßüá∑ Portuguese</button>
                        <button class="tab-button" onclick="switchTab('en-US')">üá∫üá∏ English</button>
                        <button class="tab-button" onclick="switchTab('es-ES')">üá™üá∏ Spanish</button>
                        <button class="tab-button" onclick="switchTab('fr-FR')">üá´üá∑ French</button>
                        <button class="tab-button" onclick="switchTab('de-DE')">üá©üá™ German</button>
                        <button class="tab-button" onclick="switchTab('it-IT')">üáÆüáπ Italian</button>
                    </div>
                    <div class="tab-content active" id="tab-pt-BR">
                        Portuguese transcriptions will appear here...
                    </div>
                    <div class="tab-content" id="tab-en-US">
                        English translations will appear here...
                    </div>
                    <div class="tab-content" id="tab-es-ES">
                        Spanish translations will appear here...
                    </div>
                    <div class="tab-content" id="tab-fr-FR">
                        French translations will appear here...
                    </div>
                    <div class="tab-content" id="tab-de-DE">
                        German translations will appear here...
                    </div>
                    <div class="tab-content" id="tab-it-IT">
                        Italian translations will appear here...
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let isLoggedIn = false;
        let isStreaming = false;
        let activeTab = 'pt-BR';

        // Forward declaration for admin login (defined later)
        window.adminLogin = null;

        // Check for stored admin tokens on page load
        document.addEventListener('DOMContentLoaded', async () => {
            // Wait for token check to complete before showing UI
            const hasValidTokens = await checkStoredAdminTokens();
            
            // Only setup login form if no valid tokens found
            if (hasValidTokens) {
                return; // Skip login form setup, user is already authenticated
            }
            
            // Setup admin login event listeners
            const adminUsername = document.getElementById('admin-username');
            const adminPassword = document.getElementById('admin-password');
            const adminLoginBtn = document.getElementById('admin-login-btn');
            
            adminUsername.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    document.getElementById('admin-login-btn').click();
                }
            });
            adminPassword.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    document.getElementById('admin-login-btn').click();
                }
            });
            adminLoginBtn.addEventListener('click', async () => {
                const username = document.getElementById('admin-username').value.trim();
                const password = document.getElementById('admin-password').value;
                
                if (!username || !password) {
                    showLoginStatus('Please enter username and password', 'error');
                    return;
                }
                
                adminLoginBtn.disabled = true;
                adminLoginBtn.textContent = 'üîÑ Authenticating...';
                
                try {
                    const result = await window.electronAPI.adminAuthenticate({ username, password });
                if (result.success) {
                    // Store auth result for WebSocket authentication
                    window.adminAuthResult = result;
                    
                    // Set logged in flag
                    isLoggedIn = true;
                    
                    // Hide login panel, show main app
                    document.getElementById('login-panel').classList.add('hidden');
                    document.getElementById('main-app').classList.remove('hidden');
                    document.getElementById('admin-logout-btn').classList.remove('hidden');
                    
                    showStatus(`‚úÖ Authenticated as ${result.username}`, 'success');
                        
                        // Auto-connect to WebSocket server
                        setTimeout(async () => {
                            try {
                                // Store tokens for WebSocket manager
                                if (result.token && result.refreshToken && result.tokenExpiry) {
                                    await window.electronAPI.storeAdminTokens({
                                        username: result.username,
                                        accessToken: result.token,
                                        refreshToken: result.refreshToken,
                                        expiresAt: new Date(result.tokenExpiry)
                                    });
                                }
                                
                                const connectResult = await window.electronAPI.connectWebSocket();
                                if (connectResult.success) {
                                    await new Promise(resolve => setTimeout(resolve, 500));
                                    const wsAuthResult = await window.electronAPI.adminAuthenticateWithToken({ token: result.token });
                                    if (wsAuthResult.success) {
                                        updateWebSocketStatus('connected');
                                        await refreshSessions();
                                        showStatus('‚úÖ Connected to WebSocket server', 'success');
                                    } else {
                                        console.error('WS auth failed:', wsAuthResult);
                                        showStatus('‚ö†Ô∏è WebSocket auth failed. Click Reconnect.', 'warning');
                                    }
                                } else {
                                    console.error('WS connect failed:', connectResult);
                                    showStatus('‚ö†Ô∏è WebSocket connection failed. Click Reconnect.', 'warning');
                                }
                            } catch (error) {
                                console.error('WebSocket connection/auth error:', error);
                                showStatus('‚ö†Ô∏è Click Reconnect to connect to WebSocket.', 'warning');
                            }
                        }, 100);
                    } else {
                        showLoginStatus(result.error || 'Authentication failed', 'error');
                        adminLoginBtn.disabled = false;
                        adminLoginBtn.textContent = 'üîë Login';
                    }
                } catch (error) {
                    showLoginStatus(error.message, 'error');
                    adminLoginBtn.disabled = false;
                    adminLoginBtn.textContent = 'üîë Login';
                }
            });
        });

        function handleLoginKeyPress(event) {
            if (event.key === 'Enter') {
                login();
            }
        }

        function switchConfigTab(tabName) {
            // Update active tab button
            document.querySelectorAll('#config-panel .tab-button').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // Update active tab content
            document.querySelectorAll('#config-panel .tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(`config-${tabName}`).classList.add('active');
        }

        function switchTab(language) {
            // Update active tab button
            document.querySelectorAll('.translation-panel .tab-button').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // Update active tab content
            document.querySelectorAll('.translation-panel .tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(`tab-${language}`).classList.add('active');
            
            activeTab = language;
        }

        // Load configuration on startup
        window.electronAPI.loadConfig().then(config => {
            if (config) {
                // Advanced tab
                document.getElementById('userPoolId').value = config.userPoolId || '';
                document.getElementById('clientId').value = config.clientId || '';
                document.getElementById('identityPoolId').value = config.identityPoolId || '';
                document.getElementById('region').value = config.region || 'us-east-1';
                
                // Languages tab
                const sourceLanguage = config.sourceLanguage || 'pt';
                document.querySelector(`input[name="sourceLanguage"][value="${sourceLanguage}"]`).checked = true;
                
                const targetLanguages = config.targetLanguages || ['en', 'es', 'fr', 'de', 'it'];
                ['pt', 'en', 'es', 'fr', 'de', 'it'].forEach(lang => {
                    document.getElementById(`target-${lang}`).checked = targetLanguages.includes(lang);
                });
                
                // Audio tab
                document.getElementById('inputDevice').value = config.inputDevice || 'default';
                document.getElementById('sampleRate').value = config.sampleRate || '16000';
                document.getElementById('encoding').value = config.encoding || 'signed-integer';
                document.getElementById('channels').value = config.channels || '1';
                document.getElementById('inputGain').value = config.inputGain || '100';
                updateGainDisplay();
                
                // Holyrics tab
                loadHolyricsConfig(config);
                
                // TTS tab
                loadTTSConfig(config);
            }
        });

        function updateGainDisplay() {
            const gainSlider = document.getElementById('inputGain');
            const gainValue = document.getElementById('gainValue');
            gainValue.textContent = gainSlider.value + '%';
        }

        // Update gain display when slider changes
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('inputGain').addEventListener('input', updateGainDisplay);
        });

        // Check for stored credentials on startup
        window.electronAPI.checkStoredCredentials().then(result => {
            if (result.success) {
                isLoggedIn = true;
                document.getElementById('username').value = result.username;
                document.getElementById('login-panel').classList.add('hidden');
                document.getElementById('main-app').classList.remove('hidden');
                document.getElementById('logout-btn').classList.remove('hidden');
                showStatus('Welcome back! Checking WebSocket server...', 'success');
                
                // Auto-check and start WebSocket server
                checkAndStartWebSocketServer();
            }
        });

        async function checkAndStartWebSocketServer() {
            console.info('Checking WebSocket server status, and start it if needed...');
            try {
                // First check if server is already running
                const isRunning = await checkWebSocketServerStatus();
                
                if (isRunning) {
                    updateWebSocketStatus('running');
                    updateLastActivity('Server already running');
                    showStatus('WebSocket server is already running', 'success');
                    console.info('WebSocket server is already running');
                    
                    // Try to connect
                    setTimeout(() => {
                        connectToWebSocketServer();
                    }, 1000);
                } else {
                    // Start the server
                    updateWebSocketStatus('starting');
                    showStatus('Starting WebSocket server...', 'info');
                    console.info('Starting WebSocket server...');
                    updateLastActivity('Starting server...');
                    
                    const result = await window.electronAPI.startWebSocketServer();
                    
                    if (result.success) {
                        updateWebSocketStatus('running');
                        updateLastActivity('Server started successfully');
                        showStatus('WebSocket server started successfully', 'success');
                        console.info('WebSocket server started successfully');
                        
                        // Wait longer for server to be fully ready before connecting
                        setTimeout(() => {
                            connectToWebSocketServer();
                        }, 3000);
                    } else {
                        updateWebSocketStatus('failed');
                        updateLastActivity('Server start failed');
                        showStatus(`Failed to start server: ${result.message}`, 'error');
                        console.error('Failed to start WebSocket server:', result.message);
                    }
                }
            } catch (error) {
                console.error('Error checking/starting WebSocket server:', error);
                updateWebSocketStatus('failed');
                updateLastActivity('Server check failed');
                showStatus(`Server check failed: ${error.message}`, 'error');
            }
        }

        async function checkWebSocketServerStatus() {
            try {
                const config = await window.electronAPI.loadConfig();
                const host = config?.tts?.host || 'localhost';
                const port = config?.tts?.port || 3001;
                
                console.info('Checking WebSocket server status at:', `http://${host}:${port}/health`);
                // Use HTTP health check instead of WebSocket (server uses Socket.IO, not native WebSocket)
                const response = await fetch(`http://${host}:${port}/health`, {
                    method: 'GET',
                    signal: AbortSignal.timeout(3000)
                });
                console.info('WebSocket server status response:', response);
                return response.ok;
            } catch (error) {
                console.error('Error checking WebSocket server status:', error);
                return false;
            }
        }

        let healthCheckInterval = null;

        async function connectToWebSocketServer() {
            try {
                const config = await window.electronAPI.loadConfig();
                const host = config?.tts?.host || 'localhost';
                const port = config?.tts?.port || 3001;
                const url = `ws://${host}:${port}`;
                
                // Update UI with server URL
                document.getElementById('ws-server-url').textContent = url;
                
                // Connect to WebSocket server (Socket.IO connect)
                showStatus('Connecting to WebSocket server...', 'info');
                console.info('Connecting to WebSocket server at:', url);
                const result = await window.electronAPI.connectWebSocket();
                
                if (result.success) {
                    updateWebSocketStatus('connected');
                    updateLastActivity('Connected to server');
                    showStatus('Connected to WebSocket server', 'success');
                    console.info('Connected to WebSocket server');
                    
                    // Start polling health endpoint for real-time data
                    startHealthPolling(host, port);
                } else {
                    updateWebSocketStatus('failed');
                    updateLastActivity('Connection failed');
                    showStatus(`Failed to connect: ${result.error}`, 'error');
                    console.error('Failed to connect to WebSocket server:', result.error);
                }
                
            } catch (error) {
                console.error('Failed to connect to WebSocket server:', error);
                updateWebSocketStatus('failed');
                updateLastActivity('Connection failed');
                showStatus(`Connection error: ${error.message}`, 'error');
            }
        }

        function startHealthPolling(host, port) {
            // Clear any existing interval
            if (healthCheckInterval) {
                clearInterval(healthCheckInterval);
            }
            
            // Immediate first fetch
            fetchHealthData(host, port);
            
            // Poll every 5 seconds
            healthCheckInterval = setInterval(() => {
                fetchHealthData(host, port);
            }, 5000);
        }

        function stopHealthPolling() {
            if (healthCheckInterval) {
                clearInterval(healthCheckInterval);
                healthCheckInterval = null;
            }
        }

        async function fetchHealthData(host, port) {
            try {
                const response = await fetch(`http://${host}:${port}/health`, {
                    method: 'GET',
                    signal: AbortSignal.timeout(3000)
                });
                
                if (response.ok) {
                    const healthData = await response.json();
                    updateWidgetsFromHealthData(healthData);
                }
            } catch (error) {
                console.error('Health check failed:', error);
                // Don't show error to user for polling failures
            }
        }

        function updateWidgetsFromHealthData(healthData) {
            // Update client count
            const totalClients = healthData.connections || 0;
            document.getElementById('ws-client-count').textContent = totalClients;
            
            // Update active sessions count
            const activeSessions = healthData.activeSessions || 0;
            document.getElementById('ws-session-count').textContent = activeSessions;
            
            // Update last activity timestamp
            if (healthData.timestamp) {
                updateLastActivity('Data refreshed');
            }
            
            // Update Polly cost from metrics if available
            if (healthData.metrics && healthData.metrics.pollyCost !== undefined) {
                costTracker.polly.cost = healthData.metrics.pollyCost;
                costTracker.polly.characters = healthData.metrics.pollyCharacters || 0;
                updateCostDisplay();
            }
        }

        async function reconnectWebSocket() {
            showStatus('Reconnecting to WebSocket server...', 'info');
            updateLastActivity('Reconnection requested');
            
            try {
                const isRunning = await checkWebSocketServerStatus();
                
                if (isRunning) {
                    console.info('Server is running, attempting to reconnect...');
                    const connectResult = await window.electronAPI.connectWebSocket();
                    if (connectResult.success && window.adminAuthResult?.token) {
                        await new Promise(resolve => setTimeout(resolve, 500));
                        const wsAuthResult = await window.electronAPI.adminAuthenticateWithToken({ token: window.adminAuthResult.token });
                        if (wsAuthResult.success) {
                            updateWebSocketStatus('connected');
                            await refreshSessions();
                            showStatus('Reconnected to WebSocket server', 'success');
                        }
                    }
                } else {
                    console.info('Server is not running, attempting to start...');
                    await checkAndStartWebSocketServer();
                }
            } catch (error) {
                console.error('Failed to reconnect:', error);
                showStatus(`Reconnection failed: ${error.message}`, 'error');
            }
        }

        async function stopWebSocketServer() {
            updateWebSocketStatus('stopping');
            showStatus('Stopping WebSocket server...', 'info');
            updateLastActivity('Server stop requested');
            
            // Stop streaming first if it's active
            if (isStreaming) {
                console.log('Stopping active streaming before server shutdown...');
                try {
                    await stopStreaming();
                    await new Promise(resolve => setTimeout(resolve, 500));
                } catch (error) {
                    console.error('Error stopping streaming:', error);
                }
            }
            
            // Stop health polling
            stopHealthPolling();
            
            try {
                const result = await window.electronAPI.stopWebSocketServer();
                
                if (result.success) {
                    updateWebSocketStatus('stopped');
                    updateLastActivity('Server stopped');
                    showStatus('WebSocket server stopped', 'success');
                } else {
                    updateWebSocketStatus('failed');
                    showStatus(`Failed to stop server: ${result.message}`, 'error');
                }
            } catch (error) {
                console.error('Failed to stop server:', error);
                updateWebSocketStatus('failed');
                showStatus(`Failed to stop server: ${error.message}`, 'error');
            }
        }

        function logout() {
            window.electronAPI.logout().then(() => {
                isLoggedIn = false;
                document.getElementById('main-app').classList.add('hidden');
                document.getElementById('logout-btn').classList.add('hidden');
                document.getElementById('login-panel').classList.remove('hidden');
                document.getElementById('username').value = '';
                document.getElementById('password').value = '';
                showStatus('Logged out successfully', 'info');
            });
        }

        function showConfig() {
            const panel = document.getElementById('config-panel');
            panel.classList.toggle('hidden');
            
            // Load audio devices when config panel is opened
            if (!panel.classList.contains('hidden')) {
                loadAudioDevices();
            }
        }

        async function loadAudioDevices() {
            try {
                const devices = await window.electronAPI.getAudioDevices();
                const deviceSelect = document.getElementById('inputDevice');
                const currentValue = deviceSelect.value;
                
                // Clear existing options
                deviceSelect.innerHTML = '';
                
                // Add device options
                devices.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.id;
                    option.textContent = device.name;
                    deviceSelect.appendChild(option);
                });
                
                // Restore previous selection if it exists
                if (currentValue && [...deviceSelect.options].some(opt => opt.value === currentValue)) {
                    deviceSelect.value = currentValue;
                }
            } catch (error) {
                console.error('Failed to load audio devices:', error);
            }
        }

        async function saveConfig() {
            const config = {
                // Advanced settings
                userPoolId: document.getElementById('userPoolId').value,
                clientId: document.getElementById('clientId').value,
                identityPoolId: document.getElementById('identityPoolId').value,
                region: document.getElementById('region').value,
                deviceId: 'macos-capture-local',
                
                // Language settings
                sourceLanguage: document.querySelector('input[name="sourceLanguage"]:checked')?.value || 'pt',
                targetLanguages: getTargetLanguages(),
                
                // Audio settings
                inputDevice: document.getElementById('inputDevice').value,
                sampleRate: parseInt(document.getElementById('sampleRate').value),
                encoding: document.getElementById('encoding').value,
                channels: parseInt(document.getElementById('channels').value),
                inputGain: parseInt(document.getElementById('inputGain').value),
                holyrics: {
                    enabled: document.getElementById('holyricsEnabled').checked,
                    host: document.getElementById('holyricsHost').value,
                    port: parseInt(document.getElementById('holyricsPort').value),
                    token: document.getElementById('holyricsToken').value,
                    language: document.getElementById('holyricsLanguage').value,
                    maxLines: parseInt(document.getElementById('holyricsMaxLines').value)
                },
                tts: {
                    mode: document.getElementById('ttsMode').value,
                    voiceGender: document.getElementById('ttsVoiceGender').value,
                    host: document.getElementById('ttsHost').value,
                    port: parseInt(document.getElementById('ttsPort').value)
                }
            };

            try {
                await window.electronAPI.saveConfig(config);
                
                // If a session is running, update its configuration
                const currentSessionId = document.getElementById('current-session-id').textContent;
                if (currentSessionId && currentSessionId !== 'Not Connected') {
                    showStatus('Updating active session configuration...', 'info');
                    
                    const sessionConfig = {
                        sessionId: currentSessionId,
                        enabledLanguages: config.targetLanguages,
                        ttsMode: config.tts.mode,
                        voiceGender: config.tts.voiceGender,
                        audioQuality: (config.tts.mode === 'neural' ? 'high' : 'medium')
                    };
                    
                    await window.electronAPI.updateSessionConfig(sessionConfig);
                    showStatus('Configuration saved and session updated', 'success');
                } else {
                    showStatus('Configuration saved successfully', 'success');
                }
                
                document.getElementById('config-panel').classList.add('hidden');
            } catch (error) {
                showStatus(`Failed to save configuration: ${error.message}`, 'error');
            }
        }

        // Admin authentication state
        let adminAuthState = {
            isAuthenticated: false,
            adminId: null,
            username: null,
            token: null,
            refreshToken: null,
            tokenExpiry: null,
            tokenRefreshTimer: null,
            expiryWarningTimer: null
        };

        // Admin authentication functions
        window.adminLogin = async function() {
            console.log('adminLogin called');
            const username = document.getElementById('admin-username').value.trim();
            const password = document.getElementById('admin-password').value;
            console.log('Username:', username, 'Password length:', password?.length);

            if (!username || !password) {
                showLoginStatus('Please enter username and password', 'error');
                return;
            }

            const loginBtn = document.getElementById('admin-login-btn');
            loginBtn.disabled = true;
            loginBtn.textContent = 'üîÑ Authenticating...';

            try {
                // Authenticate with WebSocket server using admin credentials
                const result = await window.electronAPI.adminAuthenticate({
                    username,
                    password
                });

                if (result.success) {
                    // Store admin authentication state
                    adminAuthState = {
                        isAuthenticated: true,
                        adminId: result.adminId,
                        username: result.username,
                        token: result.token,
                        refreshToken: result.refreshToken,
                        tokenExpiry: result.tokenExpiry ? new Date(result.tokenExpiry) : null,
                        tokenRefreshTimer: null,
                        expiryWarningTimer: null
                    };

                    // Store tokens securely
                    await storeAdminTokens(result.token, result.refreshToken, result.tokenExpiry);

                    // Setup token refresh and expiry warning timers
                    setupTokenManagement();

                    // Update UI
                    document.getElementById('login-panel').classList.add('hidden');
                    document.getElementById('main-app').classList.remove('hidden');
                    document.getElementById('admin-logout-btn').classList.remove('hidden');

                    showStatus(`‚úÖ Authenticated as ${result.username}`, 'success');

                    // Load sessions after authentication
                    if (result.ownedSessions || result.allSessions) {
                        updateSessionsList(result.ownedSessions, result.allSessions);
                    }

                    // Auto-check and start WebSocket server
                    checkAndStartWebSocketServer();
                } else {
                    showLoginStatus(result.error || 'Authentication failed', 'error');
                }
            } catch (error) {
                console.error('Admin login error:', error);
                showLoginStatus(`Authentication failed: ${error.message}`, 'error');
            } finally {
                loginBtn.disabled = false;
                loginBtn.textContent = 'üîë Login';
            }
        }

        async function adminLogout() {
            try {
                // Stop health polling
                stopHealthPolling();
                
                // Clear token management timers
                if (adminAuthState.tokenRefreshTimer) {
                    clearTimeout(adminAuthState.tokenRefreshTimer);
                }
                if (adminAuthState.expiryWarningTimer) {
                    clearTimeout(adminAuthState.expiryWarningTimer);
                }

                // Clear stored tokens
                await clearAdminTokens();

                // Disconnect WebSocket
                await window.electronAPI.disconnectWebSocket();

                // Reset admin state
                adminAuthState = {
                    isAuthenticated: false,
                    adminId: null,
                    username: null,
                    token: null,
                    refreshToken: null,
                    tokenExpiry: null,
                    tokenRefreshTimer: null,
                    expiryWarningTimer: null
                };

                // Update UI
                document.getElementById('main-app').classList.add('hidden');
                document.getElementById('login-panel').classList.remove('hidden');
                document.getElementById('admin-logout-btn').classList.add('hidden');
                document.getElementById('token-expiry-warning').classList.add('hidden');

                // Clear form
                document.getElementById('admin-username').value = '';
                document.getElementById('admin-password').value = '';

                showLoginStatus('Logged out successfully', 'info');
            } catch (error) {
                console.error('Logout error:', error);
                showStatus(`Logout error: ${error.message}`, 'error');
            }
        }

        async function refreshAdminToken() {
            if (!adminAuthState.refreshToken) {
                showStatus('No refresh token available. Please log in again.', 'error');
                await adminLogout();
                return;
            }

            try {
                const result = await window.electronAPI.refreshAdminToken({
                    refreshToken: adminAuthState.refreshToken,
                    adminId: adminAuthState.adminId
                });

                if (result.success) {
                    // Update tokens
                    adminAuthState.token = result.token;
                    adminAuthState.refreshToken = result.refreshToken || adminAuthState.refreshToken;
                    adminAuthState.tokenExpiry = result.tokenExpiry ? new Date(result.tokenExpiry) : null;

                    // Store new tokens
                    await storeAdminTokens(result.token, adminAuthState.refreshToken, result.tokenExpiry);

                    // Reset token management timers
                    setupTokenManagement();

                    // Hide expiry warning
                    document.getElementById('token-expiry-warning').classList.add('hidden');

                    showStatus('‚úÖ Session refreshed successfully', 'success');
                } else {
                    showStatus('Failed to refresh session. Please log in again.', 'error');
                    await adminLogout();
                }
            } catch (error) {
                console.error('Token refresh error:', error);
                showStatus('Failed to refresh session. Please log in again.', 'error');
                await adminLogout();
            }
        }

        function setupTokenManagement() {
            // Clear existing timers
            if (adminAuthState.tokenRefreshTimer) {
                clearTimeout(adminAuthState.tokenRefreshTimer);
            }
            if (adminAuthState.expiryWarningTimer) {
                clearTimeout(adminAuthState.expiryWarningTimer);
            }

            if (!adminAuthState.tokenExpiry) {
                return;
            }

            const now = Date.now();
            const expiryTime = adminAuthState.tokenExpiry.getTime();
            const timeUntilExpiry = expiryTime - now;

            // Show warning 5 minutes before expiry
            const warningTime = timeUntilExpiry - (5 * 60 * 1000);
            if (warningTime > 0) {
                adminAuthState.expiryWarningTimer = setTimeout(() => {
                    showTokenExpiryWarning(5);
                }, warningTime);
            }

            // Auto-refresh 2 minutes before expiry
            const refreshTime = timeUntilExpiry - (2 * 60 * 1000);
            if (refreshTime > 0) {
                adminAuthState.tokenRefreshTimer = setTimeout(() => {
                    refreshAdminToken();
                }, refreshTime);
            }
        }

        function showTokenExpiryWarning(minutesRemaining) {
            const warningDiv = document.getElementById('token-expiry-warning');
            const messageDiv = document.getElementById('token-expiry-message');
            
            messageDiv.textContent = `Your session will expire in ${minutesRemaining} minutes. Click refresh to extend.`;
            warningDiv.classList.remove('hidden');

            // Update countdown every minute
            let remaining = minutesRemaining;
            const countdownInterval = setInterval(() => {
                remaining--;
                if (remaining <= 0) {
                    clearInterval(countdownInterval);
                    messageDiv.textContent = 'Your session has expired. Please log in again.';
                    setTimeout(() => adminLogout(), 3000);
                } else {
                    messageDiv.textContent = `Your session will expire in ${remaining} minute${remaining > 1 ? 's' : ''}. Click refresh to extend.`;
                }
            }, 60000);
        }

        async function storeAdminTokens(token, refreshToken, tokenExpiry) {
            try {
                await window.electronAPI.storeAdminTokens({
                    token,
                    refreshToken,
                    tokenExpiry,
                    adminId: adminAuthState.adminId,
                    username: adminAuthState.username
                });
            } catch (error) {
                console.error('Failed to store admin tokens:', error);
            }
        }

        async function clearAdminTokens() {
            try {
                await window.electronAPI.clearAdminTokens();
            } catch (error) {
                console.error('Failed to clear admin tokens:', error);
            }
        }

        async function checkStoredAdminTokens() {
            try {
                const stored = await window.electronAPI.loadStoredAdminTokens();
                if (stored && stored.token && stored.refreshToken) {
                    console.log('Found stored tokens for:', stored.username);
                    
                    // Set admin state
                    const expiry = stored.tokenExpiry ? new Date(stored.tokenExpiry) : null;
                    adminAuthState = {
                        isAuthenticated: true,
                        adminId: stored.adminId,
                        username: stored.username,
                        token: stored.token,
                        refreshToken: stored.refreshToken,
                        tokenExpiry: expiry,
                        tokenRefreshTimer: null,
                        expiryWarningTimer: null
                    };
                    
                    // Store for later use
                    window.adminAuthResult = {
                        success: true,
                        username: stored.username,
                        token: stored.token,
                        refreshToken: stored.refreshToken,
                        tokenExpiry: expiry ? expiry.getTime() : null,
                        adminId: stored.adminId
                    };
                    
                    // Set logged in flag
                    isLoggedIn = true;
                    
                    // Update UI - hide login, show main app
                    document.getElementById('login-panel').classList.add('hidden');
                    document.getElementById('main-app').classList.remove('hidden');
                    document.getElementById('admin-logout-btn').classList.remove('hidden');
                    
                    setupTokenManagement();
                    showStatus(`‚úÖ Reconnected as ${stored.username}`, 'success');
                    
                    // Start WebSocket server - authentication will happen in connect-websocket handler
                    checkAndStartWebSocketServer();
                    return true;
                }
            } catch (error) {
                console.error('Failed to check stored tokens:', error);
            }
            return false;
        }

        function showLoginStatus(message, type) {
            const statusDiv = document.getElementById('login-status');
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
            statusDiv.classList.remove('hidden');
            
            if (type === 'success' || type === 'info') {
                setTimeout(() => {
                    statusDiv.classList.add('hidden');
                }, 3000);
            }
        }

        // Legacy login function (kept for backward compatibility with Cognito)
        async function login() {
            const username = document.getElementById('username').value;
            const password = document.getElementById('password').value;
            const config = await window.electronAPI.loadConfig();

            if (!config || !config.userPoolId || !config.clientId) {
                showStatus('Please configure the application first', 'error');
                return;
            }

            const loginBtn = document.getElementById('login-btn');
            loginBtn.disabled = true;
            loginBtn.textContent = 'Logging in...';

            try {
                const credentials = {
                    username,
                    password,
                    userPoolId: config.userPoolId,
                    clientId: config.clientId,
                    region: config.region,
                    identityPoolId: config.identityPoolId
                };

                const result = await window.electronAPI.login(credentials);
                
                if (result.success) {
                    isLoggedIn = true;
                    document.getElementById('login-panel').classList.add('hidden');
                    document.getElementById('main-app').classList.remove('hidden');
                    document.getElementById('logout-btn').classList.remove('hidden');
                    showStatus('Login successful! Checking WebSocket server...', 'success');
                    
                    // Auto-check and start WebSocket server
                    checkAndStartWebSocketServer();
                }
            } catch (error) {
                showStatus(`Login failed: ${error.message}`, 'error');
            } finally {
                loginBtn.disabled = false;
                loginBtn.textContent = 'Login';
            }
        }

        async function startStreaming() {
            if (!isLoggedIn) {
                showStatus('Please login first', 'error');
                return;
            }

            const startBtn = document.getElementById('start-btn');
            const stopBtn = document.getElementById('stop-btn');

            startBtn.disabled = true;
            startBtn.textContent = 'üé§ Starting...';

            try {
                // Update session config with current app settings before streaming
                const currentSessionId = document.getElementById('current-session-id').textContent;
                if (currentSessionId && currentSessionId !== 'Not Connected') {
                    showStatus('Updating session configuration...', 'info');
                    const config = await window.electronAPI.loadConfig();
                    
                    const sessionConfig = {
                        sessionId: currentSessionId,
                        enabledLanguages: config?.targetLanguages || ['en', 'es', 'fr', 'de', 'it'],
                        ttsMode: config?.tts?.mode || 'neural',
                        audioQuality: (config?.tts?.mode === 'neural' ? 'high' : 'medium')
                    };
                    
                    await window.electronAPI.updateSessionConfig(sessionConfig);
                }
                
                await window.electronAPI.startLocalStreaming();
                
                isStreaming = true;
                startBtn.style.display = 'none';
                stopBtn.style.display = 'inline-block';
                
                showStatus('üé§ Local streaming active - Speak into your microphone', 'info');
                
                // Clear previous results
                document.getElementById('tab-pt-BR').textContent = 'Listening...';
                document.getElementById('tab-en-US').textContent = 'Waiting for English translations...';
                document.getElementById('tab-es-ES').textContent = 'Waiting for Spanish translations...';
                document.getElementById('tab-fr-FR').textContent = 'Waiting for French translations...';
                document.getElementById('tab-de-DE').textContent = 'Waiting for German translations...';
                document.getElementById('tab-it-IT').textContent = 'Waiting for Italian translations...';
                
            } catch (error) {
                showStatus(`Failed to start streaming: ${error.message}`, 'error');
                startBtn.disabled = false;
                startBtn.textContent = 'üé§ Start Streaming';
            }
        }

        async function stopStreaming() {
            const startBtn = document.getElementById('start-btn');
            const stopBtn = document.getElementById('stop-btn');

            try {
                await window.electronAPI.stopLocalStreaming();
                
                isStreaming = false;
                stopBtn.style.display = 'none';
                startBtn.style.display = 'inline-block';
                startBtn.disabled = false;
                startBtn.textContent = 'üé§ Start Streaming';
                
                showStatus('Streaming stopped', 'info');
                
            } catch (error) {
                showStatus(`Failed to stop streaming: ${error.message}`, 'error');
            }
        }

        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
            status.classList.remove('hidden');
            
            setTimeout(() => {
                status.classList.add('hidden');
            }, 5000);
        }

        // TTS Configuration Functions
        function loadTTSConfig(config) {
            if (config && config.tts) {
                document.getElementById('ttsMode').value = config.tts.mode || 'neural';
                document.getElementById('ttsVoiceGender').value = config.tts.voiceGender || 'female';
                document.getElementById('ttsHost').value = config.tts.host || 'localhost';
                document.getElementById('ttsPort').value = config.tts.port || 3001;
            }
        }
        
        function getTargetLanguages() {
            const languages = [];
            ['pt', 'en', 'es', 'fr', 'de', 'it'].forEach(lang => {
                if (document.getElementById(`target-${lang}`).checked) {
                    languages.push(lang);
                }
            });
            return languages;
        }
        
        function generateSessionId() {
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hour = String(now.getHours()).padStart(2, '0');
            const minute = String(now.getMinutes()).padStart(2, '0');
            
            const sessionId = `CHURCH-${year}${month}${day}-${hour}${minute}`;
            document.getElementById('sessionId').value = sessionId;
            showStatus(`Generated session ID: ${sessionId}`, 'success');
        }
        
        // Session view state
        let currentSessionView = 'my'; // 'my' or 'all'
        let allSessionsData = { owned: [], all: [] };

        function switchSessionView(view) {
            currentSessionView = view;
            
            // Update tab styling
            document.getElementById('my-sessions-tab').classList.toggle('active', view === 'my');
            document.getElementById('all-sessions-tab').classList.toggle('active', view === 'all');
            
            // Update title
            document.getElementById('sessions-list-title').textContent = 
                view === 'my' ? 'My Active Sessions:' : 'All Active Sessions:';
            
            // Display appropriate sessions
            const sessionsToDisplay = view === 'my' ? allSessionsData.owned : allSessionsData.all;
            displaySessions(sessionsToDisplay);
        }

        function updateSessionsList(ownedSessions, allSessions) {
            allSessionsData = {
                owned: ownedSessions || [],
                all: allSessions || []
            };
            
            // Display based on current view
            switchSessionView(currentSessionView);
        }

        async function refreshSessions() {
            try {
                const result = await window.electronAPI.listSessions();
                
                if (!result.success) {
                    throw new Error(result.error || 'Failed to list sessions');
                }
                
                // Update sessions data
                updateSessionsList(result.ownedSessions || [], result.allSessions || result.sessions || []);
            } catch (error) {
                console.error('Failed to refresh sessions:', error);
                document.getElementById('sessions-list').innerHTML = 
                    '<div style="text-align: center; color: #f44336; padding: 20px;">Failed to load sessions</div>';
            }
        }

        function displaySessions(sessions) {
            const container = document.getElementById('sessions-list');
            const countSpan = document.getElementById('sessions-count');
            
            countSpan.textContent = `(${sessions.length})`;
            
            if (sessions.length === 0) {
                container.innerHTML = 
                    '<div style="text-align: center; color: rgba(255,255,255,0.5); padding: 20px;">No active sessions</div>';
                return;
            }
            
            container.innerHTML = sessions.map(session => {
                const isOwner = session.isOwner === true;
                const isReadOnly = !isOwner;
                const ownershipBadge = isOwner 
                    ? '<span style="background: #4CAF50; padding: 2px 8px; border-radius: 3px; font-size: 10px; margin-right: 5px;">üë§ OWNER</span>'
                    : '<span style="background: #FF9800; padding: 2px 8px; border-radius: 3px; font-size: 10px; margin-right: 5px;">üëÅÔ∏è READ-ONLY</span>';
                
                const createdByText = session.createdBy ? `Created by: ${session.createdBy}` : '';
                
                return `
                    <div style="background: rgba(255,255,255,0.05); padding: 10px; margin-bottom: 8px; border-radius: 4px; border-left: 3px solid ${isOwner ? '#4CAF50' : '#FF9800'};">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div style="flex: 1;">
                                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                                    ${ownershipBadge}
                                    <div style="font-weight: bold; color: #FFD700;">${session.sessionId}</div>
                                </div>
                                <div style="font-size: 11px; color: rgba(255,255,255,0.6);">
                                    ${session.clientCount} clients ‚Ä¢ ${session.config?.ttsMode || 'unknown'} ‚Ä¢ ${session.status}
                                </div>
                                ${createdByText ? `<div style="font-size: 10px; color: rgba(255,255,255,0.5); margin-top: 2px;">${createdByText}</div>` : ''}
                            </div>
                            <div style="display: flex; gap: 8px; align-items: center;">
                                ${isOwner ? `
                                    <button onclick="reconnectToSession('${session.sessionId}')" style="padding: 4px 12px; font-size: 11px; background: #2196F3;">
                                        ‚Üª Reconnect
                                    </button>
                                    <button onclick="endSessionFromList('${session.sessionId}')" style="padding: 4px 12px; font-size: 11px; background: #f44336;">
                                        ‚úï End
                                    </button>
                                ` : `
                                    <button onclick="viewSession('${session.sessionId}')" style="padding: 4px 12px; font-size: 11px; background: #2196F3;">
                                        üëÅÔ∏è View
                                    </button>
                                    <span style="font-size: 10px; color: rgba(255,255,255,0.5);">Read-only</span>
                                `}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        async function viewSession(sessionId) {
            showStatus(`Viewing session ${sessionId} (read-only)`, 'info');
            // In a full implementation, this would show session details in a modal or panel
        }

        async function endSessionFromList(sessionId) {
            if (!confirm(`Are you sure you want to end session ${sessionId}?`)) {
                return;
            }
            
            try {
                showStatus(`Ending session ${sessionId}...`, 'info');
                await window.electronAPI.endSession(sessionId);
                showStatus(`Session ${sessionId} ended successfully`, 'success');
                await refreshSessions();
            } catch (error) {
                showStatus(`Failed to end session: ${error.message}`, 'error');
            }
        }

        async function reconnectToSession(sessionId) {
            try {
                showStatus(`Reconnecting to session ${sessionId}...`, 'info');
                
                // Set WebSocketManager's internal session state
                const config = await window.electronAPI.loadConfig();
                const sessionConfig = {
                    sessionId,
                    enabledLanguages: config?.targetLanguages || ['en', 'es', 'fr', 'de', 'it'],
                    ttsMode: config?.tts?.mode || 'neural',
                    audioQuality: (config?.tts?.mode === 'neural' ? 'high' : 'medium')
                };
                
                await window.electronAPI.setCurrentSession(sessionConfig);
                
                // Update local UI state
                document.getElementById('current-session-id').textContent = sessionId;
                document.getElementById('sessionId').value = sessionId;
                document.getElementById('create-session-btn').classList.add('hidden');
                document.getElementById('end-session-btn').classList.remove('hidden');
                
                // Enable Start Streaming button
                const startBtn = document.getElementById('start-btn');
                startBtn.disabled = false;
                startBtn.title = '';
                
                showStatus(`Reconnected to session ${sessionId}`, 'success');
                await refreshSessions();
            } catch (error) {
                console.error('Failed to reconnect:', error);
                showStatus(`Failed to reconnect: ${error.message}`, 'error');
            }
        }

        async function endSessionFromList(sessionId) {
            if (!confirm(`End session ${sessionId}?`)) return;
            
            try {
                const result = await window.electronAPI.endSession();
                
                if (result.success) {
                    showStatus(`Session ${sessionId} ended`, 'success');
                    await refreshSessions();
                } else {
                    showStatus(`Failed to end session: ${result.error}`, 'error');
                }
            } catch (error) {
                console.error('Failed to end session:', error);
                showStatus(`Failed to end session: ${error.message}`, 'error');
            }
        }

        async function createSession() {
            const sessionId = document.getElementById('sessionId').value;
            if (!sessionId) {
                showStatus('Please enter a session ID first', 'error');
                return;
            }
            
            try {
                showStatus('Creating session...', 'info');
                
                // Load current config to pass to backend
                const config = await window.electronAPI.loadConfig();
                
                // Call backend to create session (this will connect WebSocket and create session)
                const result = await window.electronAPI.createSession(sessionId, config);
                
                if (!result.success) {
                    throw new Error(result.error || 'Failed to create session');
                }
                
                // Update UI
                document.getElementById('current-session-id').textContent = sessionId;
                document.getElementById('create-session-btn').classList.add('hidden');
                document.getElementById('end-session-btn').classList.remove('hidden');
                document.getElementById('session-panel').classList.remove('hidden');
                
                // Enable Start Streaming button
                const startBtn = document.getElementById('start-btn');
                startBtn.disabled = false;
                startBtn.title = '';
                
                showStatus(`Session ${sessionId} created successfully`, 'success');
                await refreshSessions();
            } catch (error) {
                console.error('Failed to create session:', error);
                showStatus(`Failed to create session: ${error.message}`, 'error');
            }
        }
        
        async function endCurrentSession() {
            try {
                const result = await window.electronAPI.endSession();
                
                if (result.success) {
                    document.getElementById('current-session-id').textContent = 'Not Connected';
                    document.getElementById('create-session-btn').classList.remove('hidden');
                    document.getElementById('end-session-btn').classList.add('hidden');
                    
                    // Disable Start Streaming button
                    const startBtn = document.getElementById('start-btn');
                    startBtn.disabled = true;
                    startBtn.title = 'Create a session first';
                    
                    showStatus('Session ended', 'success');
                    await refreshSessions();
                } else {
                    showStatus(`Failed to end session: ${result.error}`, 'error');
                }
            } catch (error) {
                console.error('Failed to end session:', error);
                showStatus(`Failed to end session: ${error.message}`, 'error');
            }
        }
        
        function endSession() {
            document.getElementById('current-session-id').textContent = 'Not Connected';
            document.getElementById('client-count').textContent = '0';
            document.getElementById('create-session-btn').classList.remove('hidden');
            document.getElementById('end-session-btn').classList.add('hidden');
            document.getElementById('websocket-status').textContent = 'WebSocket: Disconnected';
            document.getElementById('websocket-status').className = 'status info';
            
            showStatus('Session ended', 'info');
        }
        
        // Cost tracking functions
        let costTracker = {
            transcribe: { cost: 0, minutes: 0 },
            translate: { cost: 0, characters: 0 },
            polly: { cost: 0, characters: 0 },
            total: 0,
            hourlyRate: 0,
            sessionStart: new Date()
        };
        
        function updateCostDisplay() {
            document.getElementById('transcribe-cost').textContent = `$${costTracker.transcribe.cost.toFixed(3)}`;
            document.getElementById('transcribe-usage').textContent = `${costTracker.transcribe.minutes.toFixed(1)} min`;
            
            document.getElementById('translate-cost').textContent = `$${costTracker.translate.cost.toFixed(3)}`;
            document.getElementById('translate-usage').textContent = `${costTracker.translate.characters} chars`;
            
            document.getElementById('polly-cost').textContent = `$${costTracker.polly.cost.toFixed(3)}`;
            document.getElementById('polly-usage').textContent = `${costTracker.polly.characters} chars`;
            
            document.getElementById('total-cost').textContent = `$${costTracker.total.toFixed(3)}`;
            document.getElementById('hourly-rate').textContent = `$${costTracker.hourlyRate.toFixed(2)}/hour`;
            
            // Show warning if hourly rate exceeds $3
            const warningElement = document.getElementById('cost-warning');
            if (costTracker.hourlyRate > 3.0) {
                warningElement.classList.remove('hidden');
                warningElement.textContent = `Cost rate of $${costTracker.hourlyRate.toFixed(2)}/hour exceeds $3/hour threshold!`;
            } else {
                warningElement.classList.add('hidden');
            }
        }
        
        function trackTranscribeUsage(minutes) {
            costTracker.transcribe.minutes += minutes;
            costTracker.transcribe.cost += minutes * 0.024; // $0.024 per minute
            updateTotalCost();
        }
        
        function trackTranslateUsage(characters) {
            costTracker.translate.characters += characters;
            costTracker.translate.cost += characters * (15 / 1000000); // $15 per 1M characters
            updateTotalCost();
        }
        
        function trackPollyUsage(characters, voiceType) {
            costTracker.polly.characters += characters;
            const rate = voiceType === 'neural' ? (16 / 1000000) : (4 / 1000000);
            costTracker.polly.cost += characters * rate;
            updateTotalCost();
        }
        
        function updateTotalCost() {
            costTracker.total = costTracker.transcribe.cost + costTracker.translate.cost + costTracker.polly.cost;
            
            // Calculate hourly rate
            const sessionHours = (new Date() - costTracker.sessionStart) / (1000 * 60 * 60);
            costTracker.hourlyRate = sessionHours > 0 ? costTracker.total / sessionHours : 0;
            
            updateCostDisplay();
        }
        
        function resetCostTracking() {
            costTracker = {
                transcribe: { cost: 0, minutes: 0 },
                translate: { cost: 0, characters: 0 },
                polly: { cost: 0, characters: 0 },
                total: 0,
                hourlyRate: 0,
                sessionStart: new Date()
            };
            updateCostDisplay();
        }

        // Handle transcription results
        window.electronAPI.onTranscription((result) => {
            const content = document.getElementById('tab-pt-BR');
            if (result.isPartial) {
                content.innerHTML = content.innerHTML.split('<br><em>')[0] + '<br><em>' + result.text + '</em>';
            } else {
                content.innerHTML = content.innerHTML.replace(/<br><em>.*<\/em>/, '') + '<br>' + result.text;
                
                // Track transcription usage for cost calculation
                if (result.text && result.text.trim()) {
                    const estimatedMinutes = result.text.split(' ').length / 150; // ~150 words per minute
                    trackTranscribeUsage(estimatedMinutes);
                }
            }
            content.scrollTop = content.scrollHeight;
        });

        // Handle translation results
        window.electronAPI.onTranslation((result) => {
            result.translations.forEach(translation => {
                const tabContent = document.getElementById(`tab-${translation.targetLanguage}`);
                if (tabContent) {
                    if (translation.isPartial) {
                        tabContent.innerHTML = tabContent.innerHTML.split('<br><em>')[0] + '<br><em>' + translation.text + '</em>';
                    } else {
                        tabContent.innerHTML = tabContent.innerHTML.replace(/<br><em>.*<\/em>/, '') + '<br>' + translation.text;
                    }
                    tabContent.scrollTop = tabContent.scrollHeight;
                }
            });
            
            // Track translation usage for cost calculation
            if (result.originalText && result.translations) {
                const totalCharacters = result.originalText.length * result.translations.length;
                trackTranslateUsage(totalCharacters);
            }
        });

        // Handle streaming errors
        window.electronAPI.onStreamingError((error) => {
            showStatus(`Streaming error: ${error.error}`, 'error');
        });

        // Handle cost tracking events
        window.electronAPI.onPollyUsage((usage) => {
            console.log('Polly usage event received:', usage);
            trackPollyUsage(usage.characters, usage.voiceType);
        });

        window.electronAPI.onCostsUpdated((costs) => {
            console.log('Costs updated event received:', costs);
            costTracker = { ...costTracker, ...costs };
            updateCostDisplay();
        });

        window.electronAPI.onCostAlert((alert) => {
            console.log('Cost alert event received:', alert);
            showStatus(`Cost Alert: ${alert.message}`, 'error');
        });

        // Handle WebSocket events
        window.electronAPI.onWebSocketConnected(async () => {
            updateWebSocketStatus('connected');
            
            // Start health polling when connected
            const config = await window.electronAPI.loadConfig();
            const host = config?.tts?.host || 'localhost';
            const port = config?.tts?.port || 3001;
            startHealthPolling(host, port);
        });

        window.electronAPI.onWebSocketDisconnected(() => {
            updateWebSocketStatus('disconnected');
        });

        window.electronAPI.onClientConnected((clientInfo) => {
            updateClientCount();
            updateLastActivity('Client connected');
        });

        window.electronAPI.onClientDisconnected((clientInfo) => {
            updateClientCount();
            updateLastActivity('Client disconnected');
        });

        // Handle server-stopping event
        window.electronAPI.onServerStopping((data) => {
            console.log('Server stopping event received:', data);
            
            // Stop health polling immediately
            stopHealthPolling();
            
            // Update status
            updateWebSocketStatus('stopped');
            updateLastActivity('Server stopped');
            showStatus('WebSocket server stopped. Session preserved.', 'info');
            
            // Gray out buttons but keep session info visible
            const refreshBtn = document.getElementById('refresh-sessions-btn');
            const createBtn = document.getElementById('create-session-btn');
            const startBtn = document.getElementById('start-btn');
            const endSessionBtn = document.getElementById('end-session-btn');
            
            if (refreshBtn) refreshBtn.disabled = true;
            if (createBtn) createBtn.disabled = true;
            if (startBtn) startBtn.disabled = true;
            if (endSessionBtn) endSessionBtn.disabled = true;
            
            // Keep session ID visible but show it's disconnected
            const currentSessionId = document.getElementById('current-session-id');
            if (currentSessionId && currentSessionId.textContent !== 'Not Connected') {
                currentSessionId.style.opacity = '0.5';
            }
        });

        // Holyrics control functions
        async function testHolyricsConnection() {
            try {
                const result = await window.electronAPI.testHolyricsConnection();
                if (result.success) {
                    showStatus('Holyrics connection successful!', 'success');
                } else {
                    showStatus('Holyrics connection failed', 'error');
                }
            } catch (error) {
                showStatus(`Holyrics test failed: ${error.message}`, 'error');
            }
        }

        async function clearHolyrics() {
            try {
                await window.electronAPI.clearHolyrics();
                showStatus('Holyrics screen cleared', 'success');
            } catch (error) {
                showStatus(`Failed to clear Holyrics: ${error.message}`, 'error');
            }
        }

        // Load Holyrics configuration
        function loadHolyricsConfig(config) {
            if (config.holyrics) {
                document.getElementById('holyricsEnabled').checked = config.holyrics.enabled || false;
                document.getElementById('holyricsHost').value = config.holyrics.host || 'localhost';
                document.getElementById('holyricsPort').value = config.holyrics.port || 8080;
                document.getElementById('holyricsToken').value = config.holyrics.token || '';
                document.getElementById('holyricsLanguage').value = config.holyrics.language || 'pt';
                document.getElementById('holyricsMaxLines').value = config.holyrics.maxLines || 3;
            }
        }

        // TTS Server Health Functions
        function updateWebSocketStatus(status) {
            const statusElement = document.getElementById('ws-server-status');
            const refreshBtn = document.getElementById('refresh-sessions-btn');
            const createBtn = document.getElementById('create-session-btn');
            
            const statusMap = {
                'unknown': { text: 'Unknown', color: '#999' },
                'starting': { text: 'Starting...', color: '#FF9800' },
                'running': { text: 'Running', color: '#4CAF50' },
                'connected': { text: 'Connected', color: '#4CAF50' },
                'disconnected': { text: 'Disconnected', color: '#666' },
                'stopping': { text: 'Stopping...', color: '#FF9800' },
                'stopped': { text: 'Stopped', color: '#666' },
                'failed': { text: 'Failed', color: '#f44336' }
            };
            
            const statusInfo = statusMap[status] || statusMap['unknown'];
            statusElement.textContent = statusInfo.text;
            statusElement.style.color = statusInfo.color;
            
            // Enable buttons only when connected
            const isConnected = status === 'connected';
            if (refreshBtn) refreshBtn.disabled = !isConnected;
            if (createBtn) createBtn.disabled = !isConnected;
        }

        function updateClientCount() {
            // This would be updated from actual WebSocket events
            const count = document.getElementById('ws-client-count').textContent;
            // For now, just update the display
        }

        function updateLastActivity(activity) {
            const now = new Date();
            const timeStr = now.toLocaleTimeString();
            document.getElementById('ws-last-activity').textContent = `${activity} at ${timeStr}`;
        }

        function updateSessionId(sessionId) {
            document.getElementById('ws-session-id').textContent = sessionId || 'No Session';
        }
    </script>
</body>
</html>
